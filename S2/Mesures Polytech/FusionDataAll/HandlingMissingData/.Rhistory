3+3
install.packages("imputeTS")
library(devtools)
install_github("SteffenMoritz/imputeTS")
tsImpute(time, dimension, metric, max.iters = 2,
cv.fold = 2, n.trees = 100, verbose = T, ...)
install.packages("remotes")
remotes::install_github("dppalomar/imputeFin")
library(KFAS)
library(tseries)
library(timeSeries)
library(zoo)
library(quantmod)
install.packages("KFAS")
install.packages("timeSeries")
install.packages("zoo")
install.packages("quantmod")
install.packages("tseries")
install.packages("timeSeries")
library(KFAS)
library(tseries)
library(timeSeries)
library(zoo)
library(quantmod)
getDailyPrices = function( tickerSym, startDate, endDate )
{
prices = get.hist.quote( instrument = tickerSym, start = startDate, end = endDate,
quote="AdjClose", provider="yahoo",
compression="d",  quiet=T)
prices.ts = ts(prices)
return( prices.ts )
}
View(getDailyPrices)
View(getDailyPrices)
kalmanFilter = function( x )
{
t = x
if (class(t) != "ts") {
t = ts(t)
}
ssModel = structSSM( y = t, distribution="Gaussian")
ssFit = fitSSM(inits=c(0.5*log(var(t)), 0.5*log(var(t))), model = ssModel )
kfs = KFS( ssFit$model, smoothing="state", nsim=length(t))
vals = kfs$a
lastVal = vals[ length(vals)]
return(lastVal)
}
View(kalmanFilter)
View(kalmanFilter)
Start = "2011-01-01"
End   = "2012-12-31"
SandP = "^GSPC"
windowWidth = 20
tsLength = 100
SAndP.ts = getDailyPrices( SandP, Start, End )
SAndP.ts = SAndP.ts[1:tsLength]
SAndP.smoothed = rollapply( data=SAndP.ts, width=windowWidth, FUN=kalmanFilter)
par(mfrow=c(1,1))
prices = coredata( SAndP.ts[windowWidth:length(SAndP.ts)])
plot(prices, col="blue", type="l")
lines(coredata(SAndP.smoothed), col="magenta")
par(mfrow=c(1,1))
Start = "2011-01-01"
End   = "2012-12-31"
SandP = "GSPC"
windowWidth = 20
tsLength = 100
SAndP.ts = getDailyPrices( SandP, Start, End )
SAndP.ts = SAndP.ts[1:tsLength]
SAndP.smoothed = rollapply( data=SAndP.ts, width=windowWidth, FUN=kalmanFilter)
par(mfrow=c(1,1))
prices = coredata( SAndP.ts[windowWidth:length(SAndP.ts)])
plot(prices, col="blue", type="l")
lines(coredata(SAndP.smoothed), col="magenta")
par(mfrow=c(1,1))
View(kalmanFilter)
View(getDailyPrices)
install.packages("TTR")
library(TTR)
emaSmooth = function( x )
{
ema = EMA(x)
val = ema[ length(ema) ]
return(val)
}
emaSmooth = rollapply( data = SAndP.ts, width=windowWidth, FUN=emaSmooth)
View(emaSmooth)
library(forecast)   # Most popular forecasting pkg
library(sweep)      # Broom tidiers for forecast pkg
library(timetk)
# Working with time series in R
library(imputeTS)
setwd("~/SDSStage/SDS-Stage/S2/Mesures Polytech/FusionDataAll/HandlingMissingData")
library(tidyverse)
install.packages("broom", type="binary")
library(tidyverse)
install.packages("tidyverse")
library("broom", lib.loc="C:/Users/ahmed/anaconda3/envs/rstudio/lib/R/library")
install.packages(c("askpass", "backports", "BH", "bit", "bit64", "bitops", "broom", "caret", "caTools", "cli", "clipr", "colorspace", "config", "curl", "data.table", "DBI", "digest", "dplyr", "fansi", "fs", "generics", "glue", "haven", "highr", "htmltools", "htmlwidgets", "httpuv", "isoband", "jsonlite", "knitr", "later", "lattice", "lubridate", "magrittr", "markdown", "MASS", "Matrix", "mgcv", "mime", "mongolite", "nlme", "odbc", "openssl", "packrat", "pkgconfig", "PKI", "prettyunits", "processx", "profvis", "promises", "ps", "r2d3", "R6", "rappdirs", "Rcpp", "RCurl", "readr", "readxl", "rJava", "RJDBC", "RJSONIO", "rlang", "rmarkdown", "rprojroot", "rsconnect", "shiny", "sparklyr", "stringi", "sys", "tibble", "tidyr", "tidyselect", "tinytex", "tzdb", "utf8", "uuid", "vctrs", "vroom", "xfun", "xml2", "yaml"))
library(tidyverse)
install.packages("broom")
library(leaps)
setwd("~/SDSStage/SDS-Stage/S2/Mesures Polytech/FusionDataAll/HandlingMissingData")
library(tidyverse)
library(caret)
library(leaps)
library(MASS)
data1 = read.csv("data.csv")
data1$date <- NULL
# Fit the full model
full.model <- lm(elec_general_219_w ~., data = data1)
# Stepwise regression model
step.model <- stepAIC(full.model, direction = "both",
trace = FALSE)
summary(step.model)
# Model accuracy
step.model$results
# Final model coefficients
step.model$finalModel
# Summary of the model
summary(step.model$finalModel)
summary(step.model)
View(step.model)
summary(step.model$finalModel)
step.model$bestTune
# Stepwise regression model
step.model <- stepAIC(full.model, direction = "both", trace = FALSE)
summary(step.model)
# Model accuracy
step.model$results
# Final model coefficients
step.model$finalModel
# Summary of the model
summary(step.model$finalModel)
step.model$bestTune
#define intercept-only model
intercept_only <- lm(mpg ~ 1, data=data1)
#define intercept-only model
intercept_only <- lm(elec_general_219_w ~ 1, data=data1)
#define model with all predictors
all <- lm(elec_general_219_w ~ ., data=data1)
#perform forward stepwise regression
forward <- step(intercept_only, direction='forward', scope=formula(all), trace=0)
#view results of forward stepwise regression
forward$anova
#view final model
forward$coefficients
#perform forward stepwise regression
forward <- step(intercept_only, direction='forward', scope=formula(all), trace=1)
#view results of forward stepwise regression
forward$anova
#view final model
forward$coefficients
k <- ols_step_all_possible(forward)
plot(k)
#view final model
forward$coefficients
k <- ols_step_all_possible(forward)
plot(k)
ols_step_best_subset(forward)
k <- ols_step_all_possible(forward)
plot(k)
ols_step_best_subset(forward)
ols_step_best_subset(all)
